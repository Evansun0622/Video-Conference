{"ast":null,"code":";\n\n(function (global) {\n  var lastId = -1; // Visibility.js allow you to know, that your web page is in the background\n  // tab and thus not visible to the user. This library is wrap under\n  // Page Visibility API. It fix problems with different vendor prefixes and\n  // add high-level useful functions.\n\n  var self = {\n    // Call callback only when page become to visible for user or\n    // call it now if page is visible now or Page Visibility API\n    // doesn’t supported.\n    //\n    // Return false if API isn’t supported, true if page is already visible\n    // or listener ID (you can use it in `unbind` method) if page isn’t\n    // visible now.\n    //\n    //   Visibility.onVisible(function () {\n    //       startIntroAnimation();\n    //   });\n    onVisible: function (callback) {\n      var support = self.isSupported();\n\n      if (!support || !self.hidden()) {\n        callback();\n        return support;\n      }\n\n      var listener = self.change(function (e, state) {\n        if (!self.hidden()) {\n          self.unbind(listener);\n          callback();\n        }\n      });\n      return listener;\n    },\n    // Call callback when visibility will be changed. First argument for\n    // callback will be original event object, second will be visibility\n    // state name.\n    //\n    // Return listener ID to unbind listener by `unbind` method.\n    //\n    // If Page Visibility API doesn’t supported method will be return false\n    // and callback never will be called.\n    //\n    //   Visibility.change(function(e, state) {\n    //       Statistics.visibilityChange(state);\n    //   });\n    //\n    // It is just proxy to `visibilitychange` event, but use vendor prefix.\n    change: function (callback) {\n      if (!self.isSupported()) {\n        return false;\n      }\n\n      lastId += 1;\n      var number = lastId;\n      self._callbacks[number] = callback;\n\n      self._listen();\n\n      return number;\n    },\n    // Remove `change` listener by it ID.\n    //\n    //   var id = Visibility.change(function(e, state) {\n    //       firstChangeCallback();\n    //       Visibility.unbind(id);\n    //   });\n    unbind: function (id) {\n      delete self._callbacks[id];\n    },\n    // Call `callback` in any state, expect “prerender”. If current state\n    // is “prerender” it will wait until state will be changed.\n    // If Page Visibility API doesn’t supported, it will call `callback`\n    // immediately.\n    //\n    // Return false if API isn’t supported, true if page is already after\n    // prerendering or listener ID (you can use it in `unbind` method)\n    // if page is prerended now.\n    //\n    //   Visibility.afterPrerendering(function () {\n    //       Statistics.countVisitor();\n    //   });\n    afterPrerendering: function (callback) {\n      var support = self.isSupported();\n      var prerender = 'prerender';\n\n      if (!support || prerender != self.state()) {\n        callback();\n        return support;\n      }\n\n      var listener = self.change(function (e, state) {\n        if (prerender != state) {\n          self.unbind(listener);\n          callback();\n        }\n      });\n      return listener;\n    },\n    // Return true if page now isn’t visible to user.\n    //\n    //   if ( !Visibility.hidden() ) {\n    //       VideoPlayer.play();\n    //   }\n    //\n    // It is just proxy to `document.hidden`, but use vendor prefix.\n    hidden: function () {\n      return !!(self._doc.hidden || self._doc.webkitHidden);\n    },\n    // Return visibility state: 'visible', 'hidden' or 'prerender'.\n    //\n    //   if ( 'prerender' == Visibility.state() ) {\n    //       Statistics.pageIsPrerendering();\n    //   }\n    //\n    // Don’t use `Visibility.state()` to detect, is page visible, because\n    // visibility states can extend in next API versions.\n    // Use more simpler and general `Visibility.hidden()` for this cases.\n    //\n    // It is just proxy to `document.visibilityState`, but use\n    // vendor prefix.\n    state: function () {\n      return self._doc.visibilityState || self._doc.webkitVisibilityState || 'visible';\n    },\n    // Return true if browser support Page Visibility API.\n    // refs: https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API\n    //\n    //   if ( Visibility.isSupported() ) {\n    //       Statistics.startTrackingVisibility();\n    //       Visibility.change(function(e, state)) {\n    //           Statistics.trackVisibility(state);\n    //       });\n    //   }\n    isSupported: function () {\n      return self._doc.hidden !== undefined || self._doc.webkitHidden !== undefined;\n    },\n    // Link to document object to change it in tests.\n    _doc: document || {},\n    // Callbacks from `change` method, that wait visibility changes.\n    _callbacks: {},\n    // Listener for `visibilitychange` event.\n    _change: function (event) {\n      var state = self.state();\n\n      for (var i in self._callbacks) {\n        self._callbacks[i].call(self._doc, event, state);\n      }\n    },\n    // Set listener for `visibilitychange` event.\n    _listen: function () {\n      if (self._init) {\n        return;\n      }\n\n      var event = 'visibilitychange';\n\n      if (self._doc.webkitVisibilityState) {\n        event = 'webkit' + event;\n      }\n\n      var listener = function () {\n        self._change.apply(self, arguments);\n      };\n\n      if (self._doc.addEventListener) {\n        self._doc.addEventListener(event, listener);\n      } else {\n        self._doc.attachEvent(event, listener);\n      }\n\n      self._init = true;\n    }\n  };\n\n  if (typeof module != 'undefined' && module.exports) {\n    module.exports = self;\n  } else {\n    global.Visibility = self;\n  }\n})(this);","map":null,"metadata":{},"sourceType":"script"}